#!/usr/bin/python
#
# Copyright (C) 2012, Intel Corporation.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms and conditions of the GNU General Public License,
# version 2, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place - Suite 330, Boston, MA 02111-1307 USA.
#
# Authors:
#              Tian, Xu <xux.tian@intel.com>
#              Wang, Jing <jing.j.wang@intel.com>
#              Wei, Zhang <wei.z.zhang@intel.com>
#              Zhang, Huihui <huihuix.zhang@intel.com>
#
# Description:
#   test runner startup

import os
import re
import sys
import time
import platform
import ctypes
import xml.etree.ElementTree as etree
from optparse import *
from shutil import copyfile
from tempfile import mktemp 
from datetime import datetime

_j = os.path.join
_e = os.path.exists
_d = os.path.dirname
_b = os.path.basename
_abspath = os.path.abspath

testkit_dir = "/opt/testkit/lite"
if not platform.system() == "Linux":
    testkit_dir = _d(_abspath(__file__))
    sys.path += [_j(testkit_dir)]
    testkit_dir = _j(testkit_dir , "results")

LOG_DIR = testkit_dir
PID_FILE = _j(LOG_DIR , "pid.log")
COMMON_FILTERS = {
        "suite":          [],
        "set":            [],
        "id":             [],
        "type":           [],
        "priority":       [],
        "category":       [],
        "status":         [],
        "component":      []}

#start testkit-lite in Singleton mode
try:
    with open(PID_FILE, "r") as fd:
        pid = fd.readline().rstrip("\n")
        if pid:
            if platform.system() == "Linux":
                os.kill(int(pid), 9)
                print "[ kill existing testkit-lite, pid: %s ]" % pid
            else:
                kernel32 = ctypes.windll.kernel32
                handle = kernel32.OpenProcess(1, 0, int(pid))
                kill_result = kernel32.TerminateProcess(handle, 0)
                print "[ kill existing testkit-lite, pid: %s ]" % pid
except Exception, e:
    pattern = re.compile('No such file or directory|No such process')
    match = pattern.search(str(e))
    if not match:
        print "[ fail to kill existing testkit-lite, error: %s ]" % e

if not platform.system() == "Linux":
    try:
        if not os.path.exists(LOG_DIR):
            os.makedirs(LOG_DIR)
    except OSError, e:
        print >> sys.stderr, "\n[ create results directory: %s failed, error: %s ]\n" % (LOG_DIR, e)

try:
    with open(PID_FILE, "w") as fd:
        pid = str(os.getpid())
        fd.writelines(pid + '\n')
except Exception, e:
    print "[ can't create pid log file: %s, error: %s ]" % (PID_FILE, e)
    sys.exit(1)

try:
    os.chmod(PID_FILE, 0666)
except Exception, e:
    pass

# detect version option
if "--version" in sys.argv:
    print "[ testkit-lite v2.2.7-3 ]"
    sys.exit(1)

#get test engine, now we only got default engine
if "-E" in sys.argv:
    index = sys.argv.index("-E")
    try:
        engine = sys.argv[index + 1]
        engine = str(engine.strip()).lower()
    except IndexError:
        engine = "default"
else:
    engine = "default"

#init test engine here
try:
    exec "from testkitlite.engines.%s.runner import TRunner" % engine
    print "[ loading %s test engine ]" % engine
except ImportError, e:
    print "[ loading test engine: %s failed, error: %s ]" % (engine, e)
    print "try to run command 'export PYTHONPATH=/usr/lib/python2.7/site-packages' to resolve this issue"
    sys.exit(1)

def varnarg(option, opt_str, value, parser):
    value = []
    import re
    for arg in parser.rargs:
        if re.search('^--.+', arg) or \
           re.search('^-[\D]', arg):
            break
        value.append(arg)
        
    del parser.rargs[:len(value)]
    setattr(parser.values, option.dest, value)

try:
    option_list = [
                    make_option("-f", "--testxml", dest="testxml",
                                action="callback", callback=varnarg,
                                help="Specify the test.xml. If run more the one testxml, just list them all and separate with a whitespace"),
                    make_option("-D", "--dryrun", dest="bdryrun",
                                action="store_true",
                                help="Dry-run the selected test cases"),
                    make_option("-M", "--manual-only", dest="bmanualonly",
                                action="store_true",
                                help="Enable only manual tests"),
                    make_option("-A", "--auto-only", dest="bautoonly",
                                action="store_true",
                                help="Enable only auto tests"),
                    make_option("-o", "--output", dest="resultfile",
                                help="Specify output file for result xml. If more than one testxml provided, results will be merged together to this output file"),
                    make_option("-E", dest="engine", help="Specific test engine"),
                    make_option("-e", dest="exttest", action="store",
                                help="Launch external test with an executable file"),
                    make_option("--fullscreen", dest="fullscreen", action="store_true",
                                help="Run web API test in full screen mode"),
                    make_option("--version", dest="version_info", action="store_true",
                                help="Show version information"),
                  ]
    
    option_list.extend(map(lambda flt: \
                    make_option("--%s" % flt, dest="w%s" % flt, \
                                action="callback", callback=varnarg, \
                                help="Select the specified filter-rules : %s" % flt), COMMON_FILTERS))

    try:
        # untrusted behaviour of %%prog
        usage = "%%prog [options] -f <somewhere/test.xml>\n\
examples: %%prog  -f  <somewhere>/test.xml\n\
          %%prog  -f test.xml -D\n\
          %%prog  -f test.xml -A\n\
          %%prog  -f test.xml -M\n\
          %%prog  -f test1.xml test2.xml test3.xml ...\n\
          %%prog  -f test.xml -D -A --type type1 ...\n\
          %%prog  -f test.xml -D -A --type type1 --status ready ...\n\
\n\
    run a webapi package: \n\
          %%prog -f /usr/share/webapi-webkit-tests/tests.xml -e 'WRTLauncher webapi-webkit-tests' -o /tmp/wekit-tests-result.xml --priority P0 --status ready ...\n\
    run both core and webapi packages: \n\
          %%prog -f /usr/share/webapi-webkit-tests/tests.xml /usr/share/tts-bluez-tests/tests.xml -e 'WRTLauncher webapi-webkit-tests' -o /tmp/wekit-tests-result.xml ...\n\
\n\
Note: \n\
          1) One testxml should contains only one <suite> tag, multiple tags are not supported\n\
          2) TestLog is stored to %s/latest\n\
          3) %%prog enables both auto and manual tests by default\n\
          4) Obviously -A and -M are conflict options\n\
          5) -e option does not support -D mode\n\
          6) The test cases' order in the result files might be arbitrary, when running same tests.xml with same options. This is caused by python's API 'getiterator' from module 'xml.etree.ElementTree'\n\
          7) run command 'testkit-lite', it might not be able to locate module 'testkitlite.engines.default.runner', run command 'export PYTHONPATH=/usr/lib/python2.7/site-packages' to resolve this issue" % (LOG_DIR)
    except:
        usage = None

    # detect non-params
    if len(sys.argv) == 1:
        sys.argv.append("-h")

    parser = OptionParser(option_list=option_list, usage=usage)

    (options, args) = parser.parse_args()

    # detect conflict
    if options.bautoonly and options.bmanualonly:
        raise ValueError("-A and -M are conflict")

    # create runner
    runner = TRunner()
    runner.set_pid_log(PID_FILE)

    # apply dryrun
    if options.bdryrun:
        runner.set_dryrun(options.bdryrun)

    # apply user specify test result file
    if options.resultfile:
        runner.set_resultfile(options.resultfile)

    # apply filter
    wfilters = {}
    for flt in COMMON_FILTERS:
        if eval('options.w%s' % flt):
            wfilters[flt] = eval('options.w%s' % flt)

    if options.fullscreen:
        runner.set_fullscreen(True)

    runner.add_filter_rules(**wfilters)

    if options.exttest:
        runner.set_external_test(options.exttest)

    if not options.testxml:
        print "[ not specify a test xml... ]"
        sys.exit(1)

    # 1) prepare log dir
    if platform.system() == "Linux":
        session = datetime.today().isoformat('-')
    else:
        session = datetime.today().strftime("%Y-%m-%d_%H_%M_%S")
    log_dir = _j(LOG_DIR, session)
    latest_dir = _j(LOG_DIR, "latest")
    try:
        if _e(latest_dir):
            os.remove(latest_dir)
        os.makedirs(log_dir)
        if os.name == "posix":
            os.symlink(log_dir, latest_dir)
    except OSError, e:
        print >> sys.stderr, "\n[ create session log directory: %s failed, error: %s ]\n" % (log_dir, e)

    # 2) run test
    # run more than one tests.xml
    # 1. run all auto cases from the xmls
    # 2. run all manual cases from the xmls
    if len(options.testxml) > 1:
        testxmls = set(options.testxml)
        for t in testxmls:
            filename = t
            filename = os.path.splitext(filename)[0]
            filename = filename.split('/')[3]
            filename = "%s.total" % _b(filename)
            resultfile = "%s.xml" % filename
            resultfile = _j(log_dir, resultfile)
            ep = etree.parse(t)
            suiteparent = ep.getroot()
            no_test_definition = 1
            for tf in ep.getiterator('test_definition'):
                no_test_definition = 0
            if no_test_definition:
                suiteparent = etree.Element('test_definition')
                suiteparent.tail = "\n"
                for suite in ep.getiterator('suite'):
                    suite.tail = "\n"
                    suiteparent.append(suite)
            if options.bautoonly:
                wfilters['execution_type'] = ["auto"]
                runner.add_filter_rules(**wfilters)
            if options.bmanualonly:
                wfilters['execution_type'] = ["manual"]
                runner.add_filter_rules(**wfilters)
            runner.apply_filter(suiteparent)
            # just leave suite and set for merge result
            for suite in ep.getiterator('suite'):
                for set in suite.getiterator('set'):
                    for testcase in set.getiterator('testcase'):
                        set.remove(testcase)
            try:
                with open(resultfile, 'w') as output:
                    tree = etree.ElementTree(element=suiteparent)
                    tree.write(output)
            except IOError, e:
                print "[ create filtered total result file: %s failed, error: %s ]" % (resultfile, e)
        start_time = datetime.today().strftime("%Y-%m-%d_%H_%M_%S")
        if not options.bautoonly:
            if options.bmanualonly:
                for t in testxmls:
                    try:
                        wfilters['execution_type'] = ["manual"]
                        runner.add_filter_rules(**wfilters)
                        runner.prepare_run(t, resultdir=log_dir)
                    except Exception, e:
                        print e
            else:
                for t in testxmls:
                    try:
                        wfilters['execution_type'] = ["auto"]
                        runner.add_filter_rules(**wfilters)
                        runner.prepare_run(t, resultdir=log_dir)
                    except Exception, e:
                        print e
                for t in testxmls:
                    try:
                        wfilters['execution_type'] = ["manual"]
                        runner.add_filter_rules(**wfilters)
                        runner.prepare_run(t, resultdir=log_dir)
                    except Exception, e:
                        print e
        else:
            for t in testxmls:
                try:
                    wfilters['execution_type'] = ["auto"]
                    runner.add_filter_rules(**wfilters)
                    runner.prepare_run(t, resultdir=log_dir)
                except Exception, e:
                    print e
    # run only one tests.xml
    # 1. run all auto cases from the xml
    # 2. run all manual cases from the xml
    else:
        testxml = (options.testxml)[0]
        filename = testxml
        filename = os.path.splitext(filename)[0]
        if platform.system() == "Linux":
            filename = filename.split('/')[3]
        else:
            filename = filename.split('\\')[-2]
        filename = "%s.total" % _b(filename)
        resultfile = "%s.xml" % filename
        resultfile = _j(log_dir, resultfile)
        ep = etree.parse(testxml)
        suiteparent = ep.getroot()
        no_test_definition = 1
        for tf in ep.getiterator('test_definition'):
            no_test_definition = 0
        if no_test_definition:
            suiteparent = etree.Element('test_definition')
            suiteparent.tail = "\n"
            for suite in ep.getiterator('suite'):
                suite.tail = "\n"
                suiteparent.append(suite)
        if options.bautoonly:
            wfilters['execution_type'] = ["auto"]
            runner.add_filter_rules(**wfilters)
        if options.bmanualonly:
            wfilters['execution_type'] = ["manual"]
            runner.add_filter_rules(**wfilters)
        runner.apply_filter(suiteparent)
        # just leave suite and set for merge result
        for suite in ep.getiterator('suite'):
                for set in suite.getiterator('set'):
                    for testcase in set.getiterator('testcase'):
                        set.remove(testcase)
        try:
            with open(resultfile, 'w') as output:
                tree = etree.ElementTree(element=suiteparent)
                tree.write(output)
        except IOError, e:
            print "[ create filtered result file: %s failed, error: %s ]" % (resultfile, e)
            
        start_time = datetime.today().strftime("%Y-%m-%d_%H_%M_%S")
        if not options.bautoonly:
            if options.bmanualonly:
                try:
                    wfilters['execution_type'] = ["manual"]
                    runner.add_filter_rules(**wfilters)
                    runner.prepare_run(testxml, resultdir=log_dir)
                except Exception, e:
                    print e
            else:
                try:
                    wfilters['execution_type'] = ["auto"]
                    runner.add_filter_rules(**wfilters)
                    runner.prepare_run(testxml, resultdir=log_dir)
                    wfilters['execution_type'] = ["manual"]
                    runner.add_filter_rules(**wfilters)
                    runner.prepare_run(testxml, resultdir=log_dir)
                except Exception, e:
                    print e
        else:
            try:
                wfilters['execution_type'] = ["auto"]
                runner.add_filter_rules(**wfilters)
                runner.prepare_run(testxml, resultdir=log_dir)
            except Exception, e:
                print e
    try:
        end_time = datetime.today().strftime("%Y-%m-%d_%H_%M_%S")
        runner.run_and_merge_resultfile(start_time, end_time, log_dir)
    except Exception, e:
        print e

except KeyboardInterrupt, e:
    print >> sys.stderr, "\n[ exiting testkit-lite on user cancel ]\n"
    sys.exit(1)
except Exception, e:
    print >> sys.stderr, e
    sys.exit(1)
